// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"github.com/facebook/ent/dialect/sql"
	"github.com/faomg201/app/ent/foodmenu"
	"github.com/faomg201/app/ent/mainingre"
	"github.com/faomg201/app/ent/recordfood"
	"github.com/faomg201/app/ent/source"
	"github.com/faomg201/app/ent/user"
)

// Recordfood is the model entity for the Recordfood schema.
type Recordfood struct {
	config
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the RecordfoodQuery when eager-loading is set.
	Edges                      RecordfoodEdges `json:"edges"`
	foodmenu_foodmenu_record   *int
	mainingre_mainingre_record *int
	source_source_record       *int
	user_user_record           *int
}

// RecordfoodEdges holds the relations/edges for other nodes in the graph.
type RecordfoodEdges struct {
	// RECORDUSER holds the value of the RECORD_USER edge.
	RECORDUSER *User
	// RECORDFOODMENU holds the value of the RECORD_FOODMENU edge.
	RECORDFOODMENU *FOODMENU
	// RECORDINGREDIENT holds the value of the RECORD_INGREDIENT edge.
	RECORDINGREDIENT *Mainingre
	// RECORDSOURCE holds the value of the RECORD_SOURCE edge.
	RECORDSOURCE *Source
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [4]bool
}

// RECORDUSEROrErr returns the RECORDUSER value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e RecordfoodEdges) RECORDUSEROrErr() (*User, error) {
	if e.loadedTypes[0] {
		if e.RECORDUSER == nil {
			// The edge RECORD_USER was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: user.Label}
		}
		return e.RECORDUSER, nil
	}
	return nil, &NotLoadedError{edge: "RECORD_USER"}
}

// RECORDFOODMENUOrErr returns the RECORDFOODMENU value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e RecordfoodEdges) RECORDFOODMENUOrErr() (*FOODMENU, error) {
	if e.loadedTypes[1] {
		if e.RECORDFOODMENU == nil {
			// The edge RECORD_FOODMENU was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: foodmenu.Label}
		}
		return e.RECORDFOODMENU, nil
	}
	return nil, &NotLoadedError{edge: "RECORD_FOODMENU"}
}

// RECORDINGREDIENTOrErr returns the RECORDINGREDIENT value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e RecordfoodEdges) RECORDINGREDIENTOrErr() (*Mainingre, error) {
	if e.loadedTypes[2] {
		if e.RECORDINGREDIENT == nil {
			// The edge RECORD_INGREDIENT was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: mainingre.Label}
		}
		return e.RECORDINGREDIENT, nil
	}
	return nil, &NotLoadedError{edge: "RECORD_INGREDIENT"}
}

// RECORDSOURCEOrErr returns the RECORDSOURCE value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e RecordfoodEdges) RECORDSOURCEOrErr() (*Source, error) {
	if e.loadedTypes[3] {
		if e.RECORDSOURCE == nil {
			// The edge RECORD_SOURCE was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: source.Label}
		}
		return e.RECORDSOURCE, nil
	}
	return nil, &NotLoadedError{edge: "RECORD_SOURCE"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Recordfood) scanValues() []interface{} {
	return []interface{}{
		&sql.NullInt64{}, // id
	}
}

// fkValues returns the types for scanning foreign-keys values from sql.Rows.
func (*Recordfood) fkValues() []interface{} {
	return []interface{}{
		&sql.NullInt64{}, // foodmenu_foodmenu_record
		&sql.NullInt64{}, // mainingre_mainingre_record
		&sql.NullInt64{}, // source_source_record
		&sql.NullInt64{}, // user_user_record
	}
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Recordfood fields.
func (r *Recordfood) assignValues(values ...interface{}) error {
	if m, n := len(values), len(recordfood.Columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	value, ok := values[0].(*sql.NullInt64)
	if !ok {
		return fmt.Errorf("unexpected type %T for field id", value)
	}
	r.ID = int(value.Int64)
	values = values[1:]
	if len(values) == len(recordfood.ForeignKeys) {
		if value, ok := values[0].(*sql.NullInt64); !ok {
			return fmt.Errorf("unexpected type %T for edge-field foodmenu_foodmenu_record", value)
		} else if value.Valid {
			r.foodmenu_foodmenu_record = new(int)
			*r.foodmenu_foodmenu_record = int(value.Int64)
		}
		if value, ok := values[1].(*sql.NullInt64); !ok {
			return fmt.Errorf("unexpected type %T for edge-field mainingre_mainingre_record", value)
		} else if value.Valid {
			r.mainingre_mainingre_record = new(int)
			*r.mainingre_mainingre_record = int(value.Int64)
		}
		if value, ok := values[2].(*sql.NullInt64); !ok {
			return fmt.Errorf("unexpected type %T for edge-field source_source_record", value)
		} else if value.Valid {
			r.source_source_record = new(int)
			*r.source_source_record = int(value.Int64)
		}
		if value, ok := values[3].(*sql.NullInt64); !ok {
			return fmt.Errorf("unexpected type %T for edge-field user_user_record", value)
		} else if value.Valid {
			r.user_user_record = new(int)
			*r.user_user_record = int(value.Int64)
		}
	}
	return nil
}

// QueryRECORDUSER queries the RECORD_USER edge of the Recordfood.
func (r *Recordfood) QueryRECORDUSER() *UserQuery {
	return (&RecordfoodClient{config: r.config}).QueryRECORDUSER(r)
}

// QueryRECORDFOODMENU queries the RECORD_FOODMENU edge of the Recordfood.
func (r *Recordfood) QueryRECORDFOODMENU() *FOODMENUQuery {
	return (&RecordfoodClient{config: r.config}).QueryRECORDFOODMENU(r)
}

// QueryRECORDINGREDIENT queries the RECORD_INGREDIENT edge of the Recordfood.
func (r *Recordfood) QueryRECORDINGREDIENT() *MainingreQuery {
	return (&RecordfoodClient{config: r.config}).QueryRECORDINGREDIENT(r)
}

// QueryRECORDSOURCE queries the RECORD_SOURCE edge of the Recordfood.
func (r *Recordfood) QueryRECORDSOURCE() *SourceQuery {
	return (&RecordfoodClient{config: r.config}).QueryRECORDSOURCE(r)
}

// Update returns a builder for updating this Recordfood.
// Note that, you need to call Recordfood.Unwrap() before calling this method, if this Recordfood
// was returned from a transaction, and the transaction was committed or rolled back.
func (r *Recordfood) Update() *RecordfoodUpdateOne {
	return (&RecordfoodClient{config: r.config}).UpdateOne(r)
}

// Unwrap unwraps the entity that was returned from a transaction after it was closed,
// so that all next queries will be executed through the driver which created the transaction.
func (r *Recordfood) Unwrap() *Recordfood {
	tx, ok := r.config.driver.(*txDriver)
	if !ok {
		panic("ent: Recordfood is not a transactional entity")
	}
	r.config.driver = tx.drv
	return r
}

// String implements the fmt.Stringer.
func (r *Recordfood) String() string {
	var builder strings.Builder
	builder.WriteString("Recordfood(")
	builder.WriteString(fmt.Sprintf("id=%v", r.ID))
	builder.WriteByte(')')
	return builder.String()
}

// Recordfoods is a parsable slice of Recordfood.
type Recordfoods []*Recordfood

func (r Recordfoods) config(cfg config) {
	for _i := range r {
		r[_i].config = cfg
	}
}
